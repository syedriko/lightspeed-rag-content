# Developing Python functions


Unresolved directive in serverless-developing-python-functions.adoc - include::snippets/technology-preview.adoc[leveloffset=+2]
After you have created a Python function project, you can modify the template files provided to add business logic to your function. This includes configuring function invocation and the returned headers and status codes.

# Prerequisites

* Before you can develop functions, you must complete the steps in Configuring OpenShift Serverless Functions.

# Python function template structure

When you create a Python function by using the Knative (kn) CLI, the project directory looks similar to a typical Python project. Python functions have very few restrictions. The only requirements are that your project contains a func.py file that contains a main() function, and a func.yaml configuration file.

Developers are not restricted to the dependencies provided in the template requirements.txt file. Additional dependencies can be added as they would be in any other Python project. When the project is built for deployment, these dependencies will be included in the created runtime container image.

Both http and event trigger functions have the same template structure:


```terminal
fn
├── func.py 1
├── func.yaml 2
├── requirements.txt 3
└── test_func.py 4
```


Contains a main() function.
Used to determine the image name and registry.
Additional dependencies can be added to the requirements.txt file as they are in any other Python project.
Contains a simple unit test that can be used to test your function locally.

# About invoking Python functions

Python functions can be invoked with a simple HTTP request. When an incoming request is received, functions are invoked with a context object as the first parameter.

The context object is a Python class with two attributes:

* The request attribute is always present, and contains the Flask request object.
* The second attribute, cloud_event, is populated if the incoming request is a CloudEvent object.

Developers can access any CloudEvent data from the context object.


```python
def main(context: Context):
    """
    The context parameter contains the Flask request object and any
    CloudEvent received with the request.
    """
    print(f"Method: {context.request.method}")
    print(f"Event data {context.cloud_event.data}")
    # ... business logic here
```


# Python function return values

Functions can return any value supported by Flask. This is because the invocation framework proxies these values directly to the Flask server.


```python
def main(context: Context):
    body = { "message": "Howdy!" }
    headers = { "content-type": "application/json" }
    return body, 200, headers
```


Functions can set both headers and response codes as secondary and tertiary response values from function invocation.

## Returning CloudEvents

Developers can use the @event decorator to tell the invoker that the function return value must be converted to a CloudEvent before sending the response.


```python
@event("event_source"="/my/function", "event_type"="my.type")
def main(context):
    # business logic here
    data = do_something()
    # more data processing
    return data
```


This example sends a CloudEvent as the response value, with a type of "my.type" and a source of "/my/function". The CloudEvent data property is set to the returned data variable. The event_source and event_type decorator attributes are both optional.

# Testing Python functions

You can test Python functions locally on your computer. The default project contains a test_func.py file, which provides a simple unit test for functions.


[NOTE]
----
The default test framework for Python functions is unittest. You can use a different test framework if you prefer.
----

* To run Python functions tests locally, you must install the required dependencies:

```terminal
$ pip install -r requirements.txt
```


1. Navigate to the folder for your function that contains the test_func.py file.
2. Run the tests:

```terminal
$ python3 test_func.py
```


# Next steps

* Build and deploy a function.