# Using JSON Web Token authentication with Service Mesh 2.x

You can use JSON Web Token (JWT) authentication with Knative services by using Service Mesh 2.x and OpenShift Serverless. To do this, you must create authentication requests and policies in the application namespace that is a member of the ServiceMeshMemberRoll object. You must also enable sidecar injection for the service.

# Configuring JSON Web Token authentication for Service Mesh 2.x and OpenShift Serverless


[IMPORTANT]
----
Adding sidecar injection to pods in system namespaces, such as knative-serving and knative-serving-ingress, is not supported when Kourier is enabled.
For OpenShift Container Platform, if you require sidecar injection for pods in these namespaces, see the OpenShift Serverless documentation on Integrating Service Mesh with OpenShift Serverless natively.
----

* You have installed the OpenShift Serverless Operator, Knative Serving, and Red Hat OpenShift Service Mesh on your cluster.
* Install the OpenShift CLI (oc).
* You have created a project or have access to a project with the appropriate roles and permissions to create applications and other workloads in OpenShift Container Platform.

1. Add the sidecar.istio.io/inject="true" annotation to your service:
Example service

```yaml
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: <service_name>
spec:
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: "true" 1
        sidecar.istio.io/rewriteAppHTTPProbers: "true" 2
...
```

Add the sidecar.istio.io/inject="true" annotation.
You must set the annotation sidecar.istio.io/rewriteAppHTTPProbers: "true" in your Knative service, because OpenShift Serverless versions 1.14.0 and higher use an HTTP probe as the readiness probe for Knative services by default.
2. Apply the Service resource:

```terminal
$ oc apply -f <filename>
```

3. Create a RequestAuthentication resource in each serverless application namespace that is a member in the ServiceMeshMemberRoll object:

```yaml
apiVersion: security.istio.io/v1beta1
kind: RequestAuthentication
metadata:
  name: jwt-example
  namespace: <namespace>
spec:
  jwtRules:
  - issuer: testing@secure.istio.io
    jwksUri: https://raw.githubusercontent.com/istio/istio/release-1.8/security/tools/jwt/samples/jwks.json
```

4. Apply the RequestAuthentication resource:

```terminal
$ oc apply -f <filename>
```

5. Allow access to the RequestAuthenticaton resource from system pods for each serverless application namespace that is a member in the ServiceMeshMemberRoll object, by creating the following AuthorizationPolicy resource:

```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: allowlist-by-paths
  namespace: <namespace>
spec:
  action: ALLOW
  rules:
  - to:
    - operation:
        paths:
        - /metrics 1
        - /healthz 2
```

The path on your application to collect metrics by system pod.
The path on your application to probe by system pod.
6. Apply the AuthorizationPolicy resource:

```terminal
$ oc apply -f <filename>
```

7. For each serverless application namespace that is a member in the ServiceMeshMemberRoll object, create the following AuthorizationPolicy resource:

```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: require-jwt
  namespace: <namespace>
spec:
  action: ALLOW
  rules:
  - from:
    - source:
       requestPrincipals: ["testing@secure.istio.io/testing@secure.istio.io"]
```

8. Apply the AuthorizationPolicy resource:

```terminal
$ oc apply -f <filename>
```


1. If you try to use a curl request to get the Knative service URL, it is denied:
Example command

```terminal
$ curl http://hello-example-1-default.apps.mycluster.example.com/
```

Example output

```terminal
RBAC: access denied
```

2. Verify the request with a valid JWT.
1. Get the valid JWT token:

```terminal
$ TOKEN=$(curl https://raw.githubusercontent.com/istio/istio/release-1.8/security/tools/jwt/samples/demo.jwt -s) && echo "$TOKEN" | cut -d '.' -f2 - | base64 --decode -
```

2. Access the service by using the valid token in the curl request header:

```terminal
$ curl -H "Authorization: Bearer $TOKEN"  http://hello-example-1-default.apps.example.com
```


The request is now allowed:
Example output

```terminal
Hello OpenShift!
```
